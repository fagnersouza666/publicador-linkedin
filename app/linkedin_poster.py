import os, time
from dotenv import load_dotenv
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException, NoSuchElementException

# === Carregar vari√°veis do .env ===
load_dotenv()
EMAIL = os.getenv("LINKEDIN_EMAIL")
PWD = os.getenv("LINKEDIN_PASSWORD")
TEXT = os.getenv("POST_TEXT")
BROWSER = os.getenv("BROWSER", "firefox").lower()
DEBUG_MODE = os.getenv("DEBUG_MODE", "false").lower() == "true"  # Novo: modo debug


def log(message):
    """Log com timestamp para debug"""
    timestamp = time.strftime("%H:%M:%S")
    print(f"[{timestamp}] {message}")


def wait_for_element(driver, selectors, timeout=5, method="css"):
    """
    Aguarda por um elemento usando m√∫ltiplos seletores

    Args:
        driver: WebDriver instance
        selectors: Lista de seletores para tentar
        timeout: Tempo limite em segundos
        method: "css", "xpath" ou "mixed" (detecta automaticamente)

    Returns:
        WebElement encontrado ou None
    """
    log(f"üîç Aguardando elemento com {len(selectors)} seletores...")

    wait = WebDriverWait(driver, timeout)

    for i, selector in enumerate(selectors):
        try:
            # Verificar se a sess√£o ainda est√° ativa
            try:
                driver.current_url
            except:
                log("‚ùå Sess√£o do navegador perdida")
                return None

            if method == "mixed":
                # Detecta automaticamente se √© XPath ou CSS
                if selector.startswith("//") or selector.startswith("("):
                    element = wait.until(
                        EC.presence_of_element_located((By.XPATH, selector))
                    )
                else:
                    element = wait.until(
                        EC.presence_of_element_located((By.CSS_SELECTOR, selector))
                    )
            elif method == "xpath":
                element = wait.until(
                    EC.presence_of_element_located((By.XPATH, selector))
                )
            else:
                element = wait.until(
                    EC.presence_of_element_located((By.CSS_SELECTOR, selector))
                )

            log(f"‚úÖ Elemento encontrado com seletor {i+1}: {selector}")
            return element

        except TimeoutException:
            continue
        except Exception as e:
            log(f"‚ö†Ô∏è Erro ao procurar elemento com seletor {i+1}: {e}")
            continue

    log(f"‚ùå Nenhum elemento encontrado ap√≥s {timeout}s")
    return None


def safe_click(driver, element, description="elemento"):
    """
    Clica em um elemento de forma segura, com fallback para JavaScript
    """
    try:
        # Scroll at√© o elemento
        driver.execute_script(
            "arguments[0].scrollIntoView({block: 'center'});", element
        )
        time.sleep(0.5)

        # Tentar clique normal
        element.click()
        log(f"‚úÖ Clique normal no {description} bem-sucedido")
        return True

    except Exception as e:
        log(f"‚ö†Ô∏è Clique normal falhou no {description}: {e}")
        try:
            # Fallback para JavaScript
            driver.execute_script("arguments[0].click();", element)
            log(f"‚úÖ Clique JavaScript no {description} bem-sucedido")
            return True
        except Exception as e2:
            log(f"‚ùå Clique JavaScript tamb√©m falhou no {description}: {e2}")
            return False


# === Inicializa driver ===
def get_driver():
    log("üîß Inicializando navegador...")

    if BROWSER == "chromium" or BROWSER == "chrome":
        opts = webdriver.ChromeOptions()

        # Se DEBUG_MODE = true, n√£o usa headless
        if not DEBUG_MODE:
            opts.add_argument("--headless=new")
            log("üëª Modo headless ativado (invis√≠vel)")
        else:
            log("üëÅÔ∏è Modo visual ativado - voc√™ ver√° o navegador!")

        opts.add_argument("--disable-gpu")
        opts.add_argument("--window-size=1920,1080")
        opts.add_argument("--no-sandbox")
        opts.add_argument("--disable-dev-shm-usage")

        log("üåê Usando Chrome/Chromium...")
        return webdriver.Chrome(options=opts)
    else:
        opts = webdriver.FirefoxOptions()
        opts.binary_location = "/usr/bin/firefox"

        # Se DEBUG_MODE = true, n√£o usa headless
        if not DEBUG_MODE:
            opts.add_argument("--headless")
            log("üëª Modo headless ativado (invis√≠vel)")
        else:
            log("üëÅÔ∏è Modo visual ativado - voc√™ ver√° o navegador!")

        opts.add_argument("--width=1920")
        opts.add_argument("--height=1080")
        opts.add_argument("--no-sandbox")
        opts.add_argument("--disable-dev-shm-usage")

        # Configura√ß√µes espec√≠ficas para container Docker
        opts.set_preference("dom.webdriver.enabled", False)
        opts.set_preference("useAutomationExtension", False)

        log("ü¶ä Usando Firefox...")
        return webdriver.Firefox(options=opts)


# === Login no LinkedIn ===
def login(drv):
    log("üîê Iniciando processo de login...")

    log("üì± Acessando p√°gina de login do LinkedIn...")
    drv.get("https://www.linkedin.com/login")

    if DEBUG_MODE:
        log("‚è≥ Aguardando 3 segundos para voc√™ ver a p√°gina...")
        time.sleep(3)

    log("‚úçÔ∏è Preenchendo email...")
    username_field = drv.find_element(By.ID, "username")
    username_field.clear()
    username_field.send_keys(EMAIL)

    log("üîë Preenchendo senha...")
    password_field = drv.find_element(By.ID, "password")
    password_field.clear()
    password_field.send_keys(PWD)

    if DEBUG_MODE:
        log("‚è≥ Aguardando 2 segundos antes de clicar em entrar...")
        time.sleep(2)

    log("üöÄ Clicando no bot√£o de login...")
    password_field.send_keys(Keys.RETURN)

    log("‚è≥ Aguardando resposta do LinkedIn...")
    time.sleep(5)

    current_url = drv.current_url
    log(f"üìç URL atual: {current_url}")

    # Verifica√ß√µes de login
    if "challenge" in current_url:
        log("üö® ATEN√á√ÉO: LinkedIn est√° pedindo verifica√ß√£o adicional!")
        log("üì± VERIFICA√á√ÉO NECESS√ÅRIA:")
        log("   1Ô∏è‚É£ Abra o app LinkedIn no seu celular")
        log("   2Ô∏è‚É£ Procure a notifica√ß√£o de login")
        log("   3Ô∏è‚É£ Toque em 'Yes' para confirmar")
        log("   4Ô∏è‚É£ OU clique 'Resend' no navegador")

        if DEBUG_MODE:
            log("‚è∏Ô∏è Aguardando voc√™ resolver a verifica√ß√£o...")
            log("üí° Dica: Mantenha esta janela aberta e resolva no celular")

            # Aguardar resolu√ß√£o da verifica√ß√£o
            while "challenge" in drv.current_url:
                try:
                    response = input(
                        "‚úÖ Resolveu a verifica√ß√£o? (s/n/r=resend): "
                    ).lower()
                    if response == "s":
                        break
                    elif response == "r":
                        try:
                            resend_btn = drv.find_element(
                                By.XPATH,
                                "//button[contains(text(), 'Resend') or contains(text(), 'Reenviar')]",
                            )
                            resend_btn.click()
                            log(
                                "üì§ Bot√£o 'Resend' clicado! Verifique seu celular novamente."
                            )
                            time.sleep(3)
                        except:
                            log("‚ö†Ô∏è Bot√£o 'Resend' n√£o encontrado")
                    elif response == "n":
                        log(
                            "‚è≥ Aguardando... Digite 's' quando resolver ou 'r' para resend"
                        )

                    time.sleep(2)
                    current_url = drv.current_url
                    log(f"üìç URL atual: {current_url}")

                except KeyboardInterrupt:
                    log("‚èπÔ∏è Processo interrompido pelo usu√°rio")
                    raise Exception("Verifica√ß√£o cancelada pelo usu√°rio")

            log("‚úÖ Verifica√ß√£o resolvida! Continuando...")
        else:
            log("üí° Execute com 'python debug_local.py' para resolver interativamente")
            raise Exception(
                "Verifica√ß√£o adicional necess√°ria - use modo debug para resolver"
            )

    elif "feed" in current_url:
        log("‚úÖ Login realizado com sucesso!")
    elif "login" in current_url:
        log("‚ùå Login falhou - ainda na p√°gina de login")
        log("üîç Verificando se h√° mensagens de erro...")
        try:
            error_element = drv.find_element(
                By.CSS_SELECTOR, ".alert--error, .form__label--error"
            )
            error_text = error_element.text
            log(f"‚ùå Erro encontrado: {error_text}")
        except:
            log("‚ùå Login falhou, mas nenhuma mensagem de erro espec√≠fica encontrada")
        raise Exception(
            "Falha no login - credenciais incorretas ou verifica√ß√£o necess√°ria"
        )
    else:
        log(f"‚ö†Ô∏è URL inesperada ap√≥s login: {current_url}")
        if DEBUG_MODE:
            log("üîç Verificando se precisa de a√ß√£o manual...")
            input("‚è∏Ô∏è Pressione ENTER ap√≥s verificar a p√°gina...")


# === Publica o post ===
def publish_post(drv, text):
    log("üìù Iniciando processo de publica√ß√£o...")

    try:
        log("üì∞ Navegando para o feed...")
        drv.get("https://www.linkedin.com/feed/")
        time.sleep(3)  # Reduzido de 5 para 3

        if DEBUG_MODE:
            log("üîç P√°gina carregada, aguardando para inspe√ß√£o...")
            time.sleep(1)  # Reduzido de 2 para 1

        log("üéØ Procurando bot√£o 'Come√ßar um post'...")

        # Lista expandida de seletores poss√≠veis (LinkedIn muda frequentemente)
        start_post_selectors = [
            # Seletores mais recentes (2024)
            "button[aria-label*='Start a post']",
            "button[aria-label*='Come√ßar um post']",
            "button[aria-label*='Commencer un post']",  # Franc√™s
            "button[aria-label*='Empezar una publicaci√≥n']",  # Espanhol
            # Seletores por classe e data attributes
            ".share-box-feed-entry__trigger",
            "[data-test-id='share-box-trigger']",
            "[data-test-id='start-a-post-button']",
            ".feed-shared-update-v2__start-conversation-button",
            # Seletores por conte√∫do de texto
            "//button[contains(text(), 'Start a post')]",
            "//button[contains(text(), 'Come√ßar um post')]",
            "//button[contains(text(), 'Commencer un post')]",
            "//button[contains(text(), 'Empezar una publicaci√≥n')]",
            # Seletores gen√©ricos
            ".artdeco-button--primary[aria-label*='post']",
            "button.share-box-feed-entry__trigger",
            ".share-box-feed-entry button",
            # Fallback para textarea diretamente
            ".share-box-feed-entry__top-bar",
            "div[data-test-id='share-box']",
            # Novos seletores mais gen√©ricos
            "//button[contains(@aria-label, 'post') or contains(@aria-label, 'Post')]",
            "button[data-tracking-control-name='public_post_feed-header_publisher-text-content']",
        ]

        # Usar fun√ß√£o auxiliar para encontrar o bot√£o - timeout reduzido
        post_button = wait_for_element(
            drv, start_post_selectors, timeout=8, method="mixed"
        )

        if not post_button:
            # Tentar estrat√©gias alternativas
            log("üîÑ Tentando estrat√©gias alternativas...")

            # Verificar se h√° modal ou popup bloqueando
            try:
                close_buttons = drv.find_elements(
                    By.CSS_SELECTOR,
                    "[aria-label*='Close'], [aria-label*='Fechar'], .artdeco-modal__dismiss",
                )
                if close_buttons:
                    log("üö™ Fechando modal/popup que pode estar bloqueando...")
                    for btn in close_buttons:
                        safe_click(drv, btn, "bot√£o fechar modal")
                    time.sleep(1)  # Reduzido de 2 para 1
            except:
                pass

            # Recarregar a p√°gina
            log("üîÑ Recarregando p√°gina...")
            drv.refresh()
            time.sleep(3)  # Reduzido de 5 para 3

            # Tentar novamente com timeout menor
            post_button = wait_for_element(
                drv, start_post_selectors, timeout=5, method="mixed"
            )

            if not post_button:
                # Screenshot para debug se DEBUG_MODE ativo
                if DEBUG_MODE:
                    log("üì∏ Tirando screenshot para debug...")
                    try:
                        drv.save_screenshot("/tmp/linkedin_debug.png")
                        log("üì∑ Screenshot salvo em /tmp/linkedin_debug.png")
                    except:
                        pass

                log("‚ùå Poss√≠veis causas:")
                log("   1. LinkedIn mudou a interface")
                log("   2. Conta com restri√ß√µes de publica√ß√£o")
                log("   3. Regi√£o/idioma n√£o suportado")
                log("   4. LinkedIn detectou automa√ß√£o")

                raise Exception(
                    "Bot√£o 'Come√ßar um post' n√£o encontrado com nenhum seletor"
                )

        log("üëÜ Clicando no bot√£o para come√ßar post...")
        if not safe_click(drv, post_button, "bot√£o come√ßar post"):
            raise Exception("Falha ao clicar no bot√£o de come√ßar post")

        time.sleep(3)  # Reduzido de 4 para 3

        if DEBUG_MODE:
            log("‚è≥ Modal deve ter aberto, aguardando para inspe√ß√£o...")
            time.sleep(1)  # Reduzido de 2 para 1

        log("üìù Procurando √°rea de texto do post...")
        text_area_selectors = [
            # Seletores mais recentes
            ".ql-editor[data-placeholder]",
            ".ql-editor p",
            "div[role='textbox']",
            # Seletores por placeholder
            "[data-placeholder*='What do you want to talk about']",
            "[data-placeholder*='Do que voc√™ gostaria de falar']",
            "[data-placeholder*='De quoi voulez-vous parler']",
            "[data-placeholder*='¬øDe qu√© te gustar√≠a hablar']",
            # Seletores cl√°ssicos
            ".ql-editor",
            ".share-creation-state__text-editor .ql-editor",
            ".share-creation-state__text-editor div[role='textbox']",
            # Fallbacks
            "div[contenteditable='true']",
            ".mentions-texteditor__content",
            # Seletores mais espec√≠ficos
            ".editor-content .ql-editor",
            ".ql-container .ql-editor",
        ]

        # Usar fun√ß√£o auxiliar para encontrar √°rea de texto - timeout reduzido
        text_area = wait_for_element(drv, text_area_selectors, timeout=6, method="css")

        if not text_area:
            if DEBUG_MODE:
                log("üì∏ Tirando screenshot do modal para debug...")
                try:
                    drv.save_screenshot("/tmp/linkedin_modal_debug.png")
                    log("üì∑ Screenshot do modal salvo em /tmp/linkedin_modal_debug.png")
                except:
                    pass
            raise Exception("√Årea de texto n√£o encontrada")

        log("‚úçÔ∏è Escrevendo o texto do post...")
        # Scroll at√© a √°rea de texto
        drv.execute_script("arguments[0].scrollIntoView({block: 'center'});", text_area)
        time.sleep(0.5)  # Reduzido de 1 para 0.5

        # Focar na √°rea de texto
        if not safe_click(drv, text_area, "√°rea de texto"):
            log("‚ö†Ô∏è Falha ao clicar na √°rea de texto, tentando foco direto...")
            drv.execute_script("arguments[0].focus();", text_area)

        time.sleep(0.5)  # Reduzido de 1 para 0.5

        # Limpar conte√∫do existente e escrever texto
        try:
            text_area.send_keys(Keys.CONTROL + "a")
            time.sleep(0.3)  # Reduzido de 0.5 para 0.3
            text_area.send_keys(Keys.DELETE)
            time.sleep(0.3)  # Reduzido de 0.5 para 0.3
            text_area.send_keys(text)
            log(f"‚úÖ Texto inserido: {text[:50]}...")
        except Exception as e:
            log(f"‚ö†Ô∏è Falha ao inserir texto normalmente: {e}")
            log("üîÑ Tentando com JavaScript...")
            drv.execute_script(
                "arguments[0].innerHTML = arguments[1];", text_area, text
            )
            drv.execute_script(
                "arguments[0].textContent = arguments[1];", text_area, text
            )

        if DEBUG_MODE:
            log("‚è≥ Texto inserido, aguardando para verifica√ß√£o...")
            time.sleep(2)  # Reduzido de 3 para 2

        log("üéØ Procurando bot√£o 'Publicar'...")
        publish_selectors = [
            # Por texto em diferentes idiomas
            "//button[contains(text(),'Post') and not(contains(text(),'postpone'))]",
            "//button[contains(text(),'Publicar')]",
            "//button[contains(text(),'Publier')]",
            # Por data attributes
            "[data-test-id='share-actions-publish-button']",
            "[data-test-id='post-button']",
            "button[data-test-id*='publish']",
            # Por aria-label
            "button[aria-label*='Post']",
            "button[aria-label*='Publicar']",
            # Por classes
            ".share-actions__primary-action",
            ".artdeco-button--primary[type='submit']",
            # Seletores mais espec√≠ficos
            "button.share-actions__primary-action",
            "button[data-tracking-control-name*='publish']",
            # Fallback gen√©rico
            "button[type='submit']",
        ]

        # Usar fun√ß√£o auxiliar para encontrar bot√£o publicar - timeout reduzido
        publish_button = wait_for_element(
            drv, publish_selectors, timeout=5, method="mixed"
        )

        if not publish_button:
            if DEBUG_MODE:
                log("üì∏ Tirando screenshot dos bot√µes para debug...")
                try:
                    drv.save_screenshot("/tmp/linkedin_buttons_debug.png")
                    log(
                        "üì∑ Screenshot dos bot√µes salvo em /tmp/linkedin_buttons_debug.png"
                    )
                except:
                    pass
            raise Exception("Bot√£o 'Publicar' n√£o encontrado")

        # Verificar se bot√£o est√° habilitado
        if not publish_button.is_enabled():
            log("‚ö†Ô∏è Bot√£o publicar est√° desabilitado, aguardando...")
            time.sleep(2)  # Reduzido de 3 para 2

            if not publish_button.is_enabled():
                log(
                    "‚ùå Bot√£o ainda desabilitado. Verificando se texto foi inserido corretamente..."
                )
                if DEBUG_MODE:
                    try:
                        input("üîç Pressione ENTER ap√≥s verificar o texto na tela...")
                    except EOFError:
                        log("‚ö†Ô∏è Entrada n√£o dispon√≠vel no Docker, continuando...")

        log("üöÄ Clicando em 'Publicar'...")
        if not safe_click(drv, publish_button, "bot√£o publicar"):
            raise Exception("Falha ao clicar no bot√£o publicar")

        time.sleep(3)  # Reduzido de 5 para 3

        # Verificar se foi publicado com sucesso
        log("‚úÖ Comando de publica√ß√£o enviado!")

        if DEBUG_MODE:
            log("üîç Aguardando para verificar se foi publicado...")
            time.sleep(2)  # Reduzido de 3 para 2

            # Verificar se voltou ao feed
            try:
                current_url = drv.current_url
                if "feed" in current_url and "share" not in current_url:
                    log("‚úÖ Voltou ao feed - publica√ß√£o provavelmente bem-sucedida!")
                else:
                    log(f"‚ö†Ô∏è URL atual: {current_url}")
                    log("üîç Verifique manualmente se foi publicado")
            except:
                log("‚ö†Ô∏è N√£o foi poss√≠vel verificar URL final")

        log("‚úÖ Post publicado com sucesso!")

    except Exception as e:
        log(f"‚ùå Erro durante publica√ß√£o: {e}")

        if DEBUG_MODE:
            log("üîç Erro detectado - mantendo navegador aberto para inspe√ß√£o...")
            log("üí° Dicas para debug:")
            log("   1. Verifique se a p√°gina carregou completamente")
            log("   2. Verifique se n√£o h√° pop-ups ou notifica√ß√µes bloqueando")
            log("   3. Verifique se o idioma da interface mudou")
            log("   4. Verifique se h√° atualiza√ß√µes na interface do LinkedIn")

            try:
                current_url = drv.current_url
                log(f"üìç URL atual: {current_url}")
                page_title = drv.title
                log(f"üìã T√≠tulo da p√°gina: {page_title}")
            except:
                log("‚ö†Ô∏è N√£o foi poss√≠vel obter informa√ß√µes da p√°gina (sess√£o perdida)")

            try:
                input("‚è∏Ô∏è Pressione ENTER para continuar ap√≥s inspe√ß√£o...")
            except EOFError:
                log(
                    "‚ö†Ô∏è Entrada n√£o dispon√≠vel no Docker, continuando automaticamente..."
                )
        raise


# === Execu√ß√£o principal ===
if __name__ == "__main__":
    log("üöÄ Iniciando Publicador LinkedIn...")

    if DEBUG_MODE:
        log("üêõ MODO DEBUG ATIVADO - Processo ser√° vis√≠vel!")
    else:
        log("üëª Modo headless - processo invis√≠vel")

    log(f"üìß Email: {EMAIL}")
    log(f"üåê Navegador: {BROWSER}")
    log(f"üìù Texto: {TEXT[:50]}..." if len(TEXT) > 50 else f"üìù Texto: {TEXT}")

    driver = get_driver()
    try:
        login(driver)
        publish_post(driver, TEXT)
        log("üéâ Processo conclu√≠do com sucesso!")
    except Exception as e:
        log(f"üí• Erro geral: {e}")
        if DEBUG_MODE:
            log("üîç Mantendo navegador aberto para debug...")
            try:
                input("‚è∏Ô∏è Pressione ENTER para fechar...")
            except EOFError:
                log("‚ö†Ô∏è Entrada n√£o dispon√≠vel no Docker, fechando automaticamente...")
    finally:
        log("üîö Fechando navegador...")
        driver.quit()
        log("üëã Finalizado!")
